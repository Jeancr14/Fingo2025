



-- 1. TABLAS 

-- USUARIOS
CREATE TABLE usuarios (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR2(100) NOT NULL,
  email VARCHAR2(100) NOT NULL UNIQUE,
  telefono VARCHAR2(20),
  password VARCHAR2(255) NOT NULL,
  fecha_registro TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- CATEGORIAS
CREATE TABLE categorias (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  nombre VARCHAR2(100) NOT NULL,
  tipo VARCHAR2(20),
  descripcion VARCHAR2(255),
  CONSTRAINT fk_cat_user FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- FINANZAS
CREATE TABLE finanzas (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  categoria_id NUMBER,
  tipo VARCHAR2(20),
  monto NUMBER(12,2),
  descripcion VARCHAR2(4000),
  fecha_trx DATE,
  fecha_registro TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_fin_user FOREIGN KEY (user_id) REFERENCES usuarios(id),
  CONSTRAINT fk_fin_cat FOREIGN KEY (categoria_id) REFERENCES categorias(id)
);

-- CONFIGURACION
CREATE TABLE configuracion (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  notificaciones VARCHAR2(10) DEFAULT 'on',
  CONSTRAINT fk_conf_user FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- REPORTES
CREATE TABLE reportes (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  tipo VARCHAR2(50),
  descripcion VARCHAR2(4000),
  monto NUMBER(12,2),
  fecha DATE,
  fecha_registro TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT fk_rep_user FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- HISTORIAL
CREATE TABLE historial (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER,
  accion VARCHAR2(1000),
  fecha_registro TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- ALERTAS
CREATE TABLE alertas (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  tipo VARCHAR2(50),
  mensaje VARCHAR2(4000),
  medio VARCHAR2(20),
  fecha_envio TIMESTAMP,
  CONSTRAINT fk_alert_user FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- FAMILIARES
CREATE TABLE familiares (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  nombre VARCHAR2(100),
  email VARCHAR2(100),
  rol VARCHAR2(30),
  CONSTRAINT fk_fam_user FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- METAS_FINANCIERAS
CREATE TABLE metas_financieras (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  nombre VARCHAR2(100),
  monto_objetivo NUMBER(12,2),
  fecha_limite DATE,
  progreso NUMBER(12,2) DEFAULT 0,
  estado VARCHAR2(20) DEFAULT 'en progreso',
  CONSTRAINT fk_meta_user FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- PRESUPUESTOS
CREATE TABLE presupuestos (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  categoria_id NUMBER NOT NULL,
  monto_limite NUMBER(12,2),
  mes NUMBER(2),
  anio NUMBER(4),
  CONSTRAINT fk_pre_user FOREIGN KEY (user_id) REFERENCES usuarios(id),
  CONSTRAINT fk_pre_cat FOREIGN KEY (categoria_id) REFERENCES categorias(id)
);

-- LOGS_ACCESO
CREATE TABLE logs_acceso (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER,
  fecha_ingreso TIMESTAMP DEFAULT SYSTIMESTAMP,
  ip VARCHAR2(50),
  dispositivo VARCHAR2(100),
  CONSTRAINT fk_log_user FOREIGN KEY (user_id) REFERENCES usuarios(id)
);



-- 3. FUNCIONES 


-- Balance total
CREATE OR REPLACE FUNCTION f_get_balance(p_user_id IN NUMBER) RETURN NUMBER IS
  v_balance NUMBER := 0;
BEGIN
  SELECT NVL(SUM(CASE WHEN tipo = 'ingreso' THEN monto WHEN tipo = 'gasto' THEN -monto ELSE 0 END),0)
    INTO v_balance
    FROM finanzas WHERE user_id = p_user_id;
  RETURN v_balance;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN 0;
END;
/

-- Avance de una meta en porcentaje
CREATE OR REPLACE FUNCTION f_avance_meta(p_meta_id IN NUMBER) RETURN NUMBER IS
  v_progreso NUMBER; v_objetivo NUMBER;
BEGIN
  SELECT NVL(progreso,0), NVL(monto_objetivo,0) INTO v_progreso, v_objetivo FROM metas_financieras WHERE id = p_meta_id;
  IF NVL(v_objetivo, 0) = 0 THEN RETURN 0; ELSE RETURN ROUND((v_progreso / v_objetivo) * 100,2); END IF;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN 0;
END;
/

-- Total gastos de un mes
CREATE OR REPLACE FUNCTION f_total_gastos_mes(p_user_id IN NUMBER, p_mes IN NUMBER, p_anio IN NUMBER) RETURN NUMBER IS
  v_total NUMBER;
BEGIN
  SELECT NVL(SUM(monto),0) INTO v_total
  FROM finanzas
  WHERE user_id=p_user_id AND tipo='gasto'
    AND EXTRACT(MONTH FROM fecha_trx)=p_mes
    AND EXTRACT(YEAR FROM fecha_trx)=p_anio;
  RETURN v_total;
END;
/

-- f_get_saldo_categoria que es el saldo por categoría
CREATE OR REPLACE FUNCTION f_get_saldo_categoria(p_user_id IN NUMBER, p_categoria_id IN NUMBER) RETURN NUMBER IS
  v_saldo NUMBER := 0;
BEGIN
  SELECT NVL(SUM(CASE WHEN tipo = 'ingreso' THEN monto WHEN tipo = 'gasto' THEN -monto ELSE 0 END), 0)
  INTO v_saldo
  FROM finanzas
  WHERE user_id = p_user_id AND categoria_id = p_categoria_id;
  RETURN v_saldo;
END;
/

-- f_es_presupuesto_excedido que es el exceso de presupuesto
CREATE OR REPLACE FUNCTION f_es_presupuesto_excedido(p_presupuesto_id IN NUMBER)
RETURN VARCHAR2 IS
  v_limite NUMBER; v_gasto_actual NUMBER; v_mes NUMBER; v_anio NUMBER; v_user_id NUMBER;
BEGIN
  SELECT p.monto_limite, p.mes, p.anio, p.user_id
  INTO v_limite, v_mes, v_anio, v_user_id
  FROM presupuestos p WHERE id = p_presupuesto_id;
  v_gasto_actual := f_total_gastos_mes(v_user_id, v_mes, v_anio);
  IF v_gasto_actual > v_limite THEN RETURN 'SI'; ELSE RETURN 'NO'; END IF;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN 'N/A';
END;
/

-- f_conteo_familiares es el conteo de familiares
CREATE OR REPLACE FUNCTION f_conteo_familiares(p_user_id IN NUMBER) RETURN NUMBER IS
  v_total NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_total FROM familiares WHERE user_id = p_user_id;
  RETURN v_total;
END;
/

-- f_porcentaje_uso_presupuesto es el porcentaje de uso de presupuesto
CREATE OR REPLACE FUNCTION f_porcentaje_uso_presupuesto(p_presupuesto_id IN NUMBER)
RETURN NUMBER IS
  v_limite NUMBER; v_gasto_actual NUMBER; v_mes NUMBER; v_anio NUMBER; v_user_id NUMBER;
BEGIN
  SELECT p.monto_limite, p.mes, p.anio, p.user_id
  INTO v_limite, v_mes, v_anio, v_user_id
  FROM presupuestos p WHERE id = p_presupuesto_id;
  v_gasto_actual := f_total_gastos_mes(v_user_id, v_mes, v_anio);
  IF NVL(v_limite, 0) = 0 THEN RETURN 0; ELSE RETURN ROUND((v_gasto_actual / v_limite) * 100, 2); END IF;
EXCEPTION WHEN NO_DATA_FOUND THEN RETURN 0;
END;
/

-- f_conteo_trx_tipo para contar transacciones por tipo
CREATE OR REPLACE FUNCTION f_conteo_trx_tipo(p_user_id IN NUMBER, p_tipo IN VARCHAR2)
RETURN NUMBER IS
  v_total NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_total FROM finanzas
  WHERE user_id = p_user_id AND tipo = p_tipo;
  RETURN v_total;
END;
/



-- 4. VISTAS 


CREATE OR REPLACE VIEW vw_user_summary AS
SELECT u.id, u.nombre, u.email, u.fecha_registro,
       f_get_balance(u.id) AS balance_total,
       f_conteo_trx_tipo(u.id, 'ingreso') AS ingresos,
       f_conteo_trx_tipo(u.id, 'gasto') AS gastos
FROM usuarios u;
/

CREATE OR REPLACE VIEW vw_metas_progreso AS
SELECT m.id, u.nombre usuario, m.nombre meta, m.monto_objetivo, m.progreso,
       f_avance_meta(m.id) avance_porcentaje, m.estado
FROM metas_financieras m
JOIN usuarios u ON m.user_id = u.id;
/

CREATE OR REPLACE VIEW vw_gastos_mensuales AS
SELECT u.id usuario_id, u.nombre, EXTRACT(MONTH FROM f.fecha_trx) mes,
       EXTRACT(YEAR FROM f.fecha_trx) anio, SUM(f.monto) total_gasto
FROM finanzas f JOIN usuarios u ON f.user_id=u.id
WHERE f.tipo='gasto'
GROUP BY u.id, u.nombre, EXTRACT(MONTH FROM f.fecha_trx), EXTRACT(YEAR FROM f.fecha_trx);
/

CREATE OR REPLACE VIEW vw_presupuestos_actuales AS
SELECT
    p.id AS presupuesto_id,
    u.nombre AS usuario,
    c.nombre AS categoria,
    p.monto_limite,
    p.mes,
    p.anio,
    f_porcentaje_uso_presupuesto(p.id) AS porcentaje_uso
FROM presupuestos p
JOIN usuarios u ON p.user_id = u.id
JOIN categorias c ON p.categoria_id = c.id;
/

CREATE OR REPLACE VIEW vw_alerta_usuarios AS
SELECT DISTINCT
    u.id AS user_id,
    u.nombre AS nombre_usuario,
    u.email,
    COUNT(a.id) AS total_alertas_pendientes
FROM usuarios u
JOIN alertas a ON u.id = a.user_id
WHERE a.fecha_envio IS NULL
GROUP BY u.id, u.nombre, u.email;
/


-- 5. PROCEDIMIENTOS ALMACENADOS (CRUD PARA TODAS LAS TABLAS)


-- CRUD USUARIOS
CREATE OR REPLACE PROCEDURE p_create_usuario(p_nombre IN VARCHAR2, p_email IN VARCHAR2, p_telefono IN VARCHAR2, p_password IN VARCHAR2, p_id OUT NUMBER) AS
BEGIN INSERT INTO usuarios(nombre, email, telefono, password) VALUES (p_nombre, p_email, p_telefono, p_password) RETURNING id INTO p_id; COMMIT; EXCEPTION WHEN OTHERS THEN ROLLBACK; RAISE; END;
/
CREATE OR REPLACE PROCEDURE p_read_usuario(p_id IN NUMBER, p_nombre OUT VARCHAR2, p_email OUT VARCHAR2, p_telefono OUT VARCHAR2, p_fecha_registro OUT TIMESTAMP) AS
BEGIN SELECT nombre, email, telefono, fecha_registro INTO p_nombre, p_email, p_telefono, p_fecha_registro FROM usuarios WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_nombre := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_usuario(p_id IN NUMBER, p_nombre IN VARCHAR2, p_email IN VARCHAR2, p_telefono IN VARCHAR2) AS
BEGIN UPDATE usuarios SET nombre = p_nombre, email = p_email, telefono = p_telefono WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_usuario(p_id IN NUMBER) AS
BEGIN DELETE FROM usuarios WHERE id = p_id; COMMIT; END;
/

-- CRUD CATEGORIAS
CREATE OR REPLACE PROCEDURE p_create_categoria(p_user_id IN NUMBER, p_nombre IN VARCHAR2, p_tipo IN VARCHAR2, p_descripcion IN VARCHAR2, p_id OUT NUMBER) AS
BEGIN INSERT INTO categorias(user_id, nombre, tipo, descripcion) VALUES (p_user_id, p_nombre, p_tipo, p_descripcion) RETURNING id INTO p_id; COMMIT; EXCEPTION WHEN OTHERS THEN ROLLBACK; RAISE; END;
/
CREATE OR REPLACE PROCEDURE p_read_categoria(p_id IN NUMBER, p_user_id OUT NUMBER, p_nombre OUT VARCHAR2, p_tipo OUT VARCHAR2, p_descripcion OUT VARCHAR2) AS
BEGIN SELECT user_id, nombre, tipo, descripcion INTO p_user_id, p_nombre, p_tipo, p_descripcion FROM categorias WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_nombre := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_categoria(p_id IN NUMBER, p_nombre IN VARCHAR2, p_tipo IN VARCHAR2, p_descripcion IN VARCHAR2) AS
BEGIN UPDATE categorias SET nombre = p_nombre, tipo = p_tipo, descripcion = p_descripcion WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_categoria(p_id IN NUMBER) AS
BEGIN DELETE FROM categorias WHERE id = p_id; COMMIT; END;
/

-- CRUD FINANZAS
CREATE OR REPLACE PROCEDURE p_create_finanza(p_user_id IN NUMBER, p_categoria_id IN NUMBER, p_tipo IN VARCHAR2, p_monto IN NUMBER, p_descripcion IN VARCHAR2, p_fecha_trx IN DATE, p_id OUT NUMBER) AS
BEGIN INSERT INTO finanzas(user_id, categoria_id, tipo, monto, descripcion, fecha_trx) VALUES (p_user_id, p_categoria_id, p_tipo, p_monto, p_descripcion, p_fecha_trx) RETURNING id INTO p_id; COMMIT; EXCEPTION WHEN OTHERS THEN ROLLBACK; RAISE; END;
/
CREATE OR REPLACE PROCEDURE p_read_finanza(p_id IN NUMBER, p_user_id OUT NUMBER, p_tipo OUT VARCHAR2, p_monto OUT NUMBER) AS
BEGIN SELECT user_id, tipo, monto INTO p_user_id, p_tipo, p_monto FROM finanzas WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_user_id := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_finanza(p_id IN NUMBER, p_monto IN NUMBER, p_descripcion IN VARCHAR2) AS
BEGIN UPDATE finanzas SET monto = p_monto, descripcion = p_descripcion WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_finanza(p_id IN NUMBER) AS
BEGIN DELETE FROM finanzas WHERE id = p_id; COMMIT; END;
/

-- CRUD METAS_FINANCIERAS
CREATE OR REPLACE PROCEDURE p_create_meta(p_user_id IN NUMBER, p_nombre IN VARCHAR2, p_monto_objetivo IN NUMBER, p_fecha_limite IN DATE, p_id OUT NUMBER) AS
BEGIN INSERT INTO metas_financieras(user_id, nombre, monto_objetivo, fecha_limite) VALUES (p_user_id, p_nombre, p_monto_objetivo, p_fecha_limite) RETURNING id INTO p_id; COMMIT; EXCEPTION WHEN OTHERS THEN ROLLBACK; RAISE; END;
/
CREATE OR REPLACE PROCEDURE p_read_meta(p_id IN NUMBER, p_nombre OUT VARCHAR2, p_objetivo OUT NUMBER, p_progreso OUT NUMBER) AS
BEGIN SELECT nombre, monto_objetivo, progreso INTO p_nombre, p_objetivo, p_progreso FROM metas_financieras WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_nombre := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_meta(p_id IN NUMBER, p_nombre IN VARCHAR2, p_estado IN VARCHAR2) AS
BEGIN UPDATE metas_financieras SET nombre = p_nombre, estado = p_estado WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_update_meta_progreso(p_meta_id IN NUMBER, p_progreso IN NUMBER) AS
BEGIN UPDATE metas_financieras SET progreso = p_progreso WHERE id = p_meta_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_meta(p_id IN NUMBER) AS
BEGIN DELETE FROM metas_financieras WHERE id = p_id; COMMIT; END;
/

-- CRUD CONFIGURACION
CREATE OR REPLACE PROCEDURE p_create_configuracion(p_user_id IN NUMBER, p_notificaciones IN VARCHAR2, p_id OUT NUMBER) AS
BEGIN INSERT INTO configuracion(user_id, notificaciones) VALUES (p_user_id, p_notificaciones) RETURNING id INTO p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_read_configuracion(p_id IN NUMBER, p_user_id OUT NUMBER, p_notificaciones OUT VARCHAR2) AS
BEGIN SELECT user_id, notificaciones INTO p_user_id, p_notificaciones FROM configuracion WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_configuracion(p_id IN NUMBER, p_notificaciones IN VARCHAR2) AS
BEGIN UPDATE configuracion SET notificaciones = p_notificaciones WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_configuracion(p_id IN NUMBER) AS
BEGIN DELETE FROM configuracion WHERE id = p_id; COMMIT; END;
/

-- CRUD REPORTES
CREATE OR REPLACE PROCEDURE p_create_reporte(p_user_id IN NUMBER, p_tipo IN VARCHAR2, p_monto IN NUMBER, p_fecha IN DATE, p_id OUT NUMBER) AS
BEGIN INSERT INTO reportes(user_id, tipo, monto, fecha) VALUES (p_user_id, p_tipo, p_monto, p_fecha) RETURNING id INTO p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_read_reporte(p_id IN NUMBER, p_tipo OUT VARCHAR2, p_monto OUT NUMBER) AS
BEGIN SELECT tipo, monto INTO p_tipo, p_monto FROM reportes WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_tipo := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_reporte(p_id IN NUMBER, p_tipo IN VARCHAR2) AS
BEGIN UPDATE reportes SET tipo = p_tipo WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_reporte(p_id IN NUMBER) AS
BEGIN DELETE FROM reportes WHERE id = p_id; COMMIT; END;
/

-- CRUD HISTORIAL (Solo C y R relevantes)
CREATE OR REPLACE PROCEDURE p_create_historial(p_user_id IN NUMBER, p_accion IN VARCHAR2, p_id OUT NUMBER) AS
BEGIN INSERT INTO historial(user_id, accion) VALUES (p_user_id, p_accion) RETURNING id INTO p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_read_historial(p_id IN NUMBER, p_accion OUT VARCHAR2) AS
BEGIN SELECT accion INTO p_accion FROM historial WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_accion := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_delete_historial(p_id IN NUMBER) AS
BEGIN DELETE FROM historial WHERE id = p_id; COMMIT; END;
/

-- CRUD ALERTAS
CREATE OR REPLACE PROCEDURE p_create_alerta(p_user_id IN NUMBER, p_tipo IN VARCHAR2, p_mensaje IN VARCHAR2, p_id OUT NUMBER) AS
BEGIN INSERT INTO alertas(user_id, tipo, mensaje) VALUES (p_user_id, p_tipo, p_mensaje) RETURNING id INTO p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_read_alerta(p_id IN NUMBER, p_mensaje OUT VARCHAR2, p_fecha_envio OUT TIMESTAMP) AS
BEGIN SELECT mensaje, fecha_envio INTO p_mensaje, p_fecha_envio FROM alertas WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_mensaje := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_alerta(p_id IN NUMBER, p_mensaje IN VARCHAR2) AS
BEGIN UPDATE alertas SET mensaje = p_mensaje WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_alerta(p_id IN NUMBER) AS
BEGIN DELETE FROM alertas WHERE id = p_id; COMMIT; END;
/

-- CRUD FAMILIARES
CREATE OR REPLACE PROCEDURE p_create_familiar(p_user_id IN NUMBER, p_nombre IN VARCHAR2, p_email IN VARCHAR2, p_id OUT NUMBER) AS
BEGIN INSERT INTO familiares(user_id, nombre, email) VALUES (p_user_id, p_nombre, p_email) RETURNING id INTO p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_read_familiar(p_id IN NUMBER, p_nombre OUT VARCHAR2, p_rol OUT VARCHAR2) AS
BEGIN SELECT nombre, rol INTO p_nombre, p_rol FROM familiares WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_nombre := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_familiar(p_id IN NUMBER, p_rol IN VARCHAR2) AS
BEGIN UPDATE familiares SET rol = p_rol WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_familiar(p_id IN NUMBER) AS
BEGIN DELETE FROM familiares WHERE id = p_id; COMMIT; END;
/

-- CRUD PRESUPUESTOS
CREATE OR REPLACE PROCEDURE p_create_presupuesto(p_user_id IN NUMBER, p_categoria_id IN NUMBER, p_monto_limite IN NUMBER, p_mes IN NUMBER, p_anio IN NUMBER, p_id OUT NUMBER) AS
BEGIN INSERT INTO presupuestos(user_id, categoria_id, monto_limite, mes, anio) VALUES (p_user_id, p_categoria_id, p_monto_limite, p_mes, p_anio) RETURNING id INTO p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_read_presupuesto(p_id IN NUMBER, p_limite OUT NUMBER, p_mes OUT NUMBER, p_anio OUT NUMBER) AS
BEGIN SELECT monto_limite, mes, anio INTO p_limite, p_mes, p_anio FROM presupuestos WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_limite := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_update_presupuesto(p_id IN NUMBER, p_monto_limite IN NUMBER) AS
BEGIN UPDATE presupuestos SET monto_limite = p_monto_limite WHERE id = p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_delete_presupuesto(p_id IN NUMBER) AS
BEGIN DELETE FROM presupuestos WHERE id = p_id; COMMIT; END;
/

-- CRUD LOGS_ACCESO (Solo C y R relevantes)
CREATE OR REPLACE PROCEDURE p_create_log_acceso(p_user_id IN NUMBER, p_ip IN VARCHAR2, p_dispositivo IN VARCHAR2, p_id OUT NUMBER) AS
BEGIN INSERT INTO logs_acceso(user_id, ip, dispositivo) VALUES (p_user_id, p_ip, p_dispositivo) RETURNING id INTO p_id; COMMIT; END;
/
CREATE OR REPLACE PROCEDURE p_read_log_acceso(p_id IN NUMBER, p_ip OUT VARCHAR2, p_fecha OUT TIMESTAMP) AS
BEGIN SELECT ip, fecha_ingreso INTO p_ip, p_fecha FROM logs_acceso WHERE id = p_id; EXCEPTION WHEN NO_DATA_FOUND THEN p_ip := NULL; END;
/
CREATE OR REPLACE PROCEDURE p_delete_log_acceso(p_id IN NUMBER) AS
BEGIN DELETE FROM logs_acceso WHERE id = p_id; COMMIT; END;
/



-- 6. TRIGGERS


-- 1. Trigger de Auditoría para Finanzas
CREATE OR REPLACE TRIGGER trg_finanzas_audit
AFTER INSERT OR UPDATE OR DELETE ON finanzas
FOR EACH ROW
DECLARE v_accion VARCHAR2(500);
BEGIN
  IF INSERTING THEN v_accion := 'INSERT en finanzas id=' || NVL(:NEW.id, -1) || ' user=' || NVL(:NEW.user_id,-1);
  ELSIF UPDATING THEN v_accion := 'UPDATE en finanzas id=' || NVL(:NEW.id, -1) || ' user=' || NVL(:NEW.user_id,-1);
  ELSIF DELETING THEN v_accion := 'DELETE en finanzas id=' || NVL(:OLD.id, -1) || ' user=' || NVL(:OLD.user_id,-1); END IF;
  INSERT INTO historial(user_id, accion) VALUES (NVL(NVL(:NEW.user_id, :OLD.user_id), -1), v_accion);
END;
/

-- 2. Trigger de Auditoría para Usuarios
CREATE OR REPLACE TRIGGER trg_usuario_audit
AFTER INSERT ON usuarios
FOR EACH ROW
BEGIN
  INSERT INTO historial(user_id, accion) VALUES (:NEW.id, 'CREAR_USUARIO:'||:NEW.email);
END;
/

-- 3. Trigger de Lógica de Negocio (Validación)
CREATE OR REPLACE TRIGGER trg_monto_positivo_finanza
BEFORE INSERT OR UPDATE ON finanzas
FOR EACH ROW
BEGIN
  IF :NEW.monto <= 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'El monto de la transacción debe ser un valor positivo.');
  END IF;
END;
/



-- 7. PAQUETES 


-- PAQUETE 1: fingo_pkg 
CREATE OR REPLACE PACKAGE fingo_pkg IS
  CURSOR c_finanzas(p_user NUMBER) IS SELECT id, tipo, monto, fecha_trx FROM finanzas WHERE user_id=p_user ORDER BY fecha_trx DESC;
  PROCEDURE p_listar_finanzas(p_user NUMBER);
  FUNCTION f_conteo_finanzas(p_user NUMBER) RETURN NUMBER;
  FUNCTION f_balance_resumido(p_user NUMBER) RETURN NUMBER;
END fingo_pkg;
/
CREATE OR REPLACE PACKAGE BODY fingo_pkg IS
  PROCEDURE p_listar_finanzas(p_user NUMBER) IS
    v_rec c_finanzas%ROWTYPE;
  BEGIN
    FOR v_rec IN c_finanzas(p_user) LOOP DBMS_OUTPUT.PUT_LINE('ID='||v_rec.id||' TIPO='||v_rec.tipo||' MONTO='||v_rec.monto); END LOOP;
  END p_listar_finanzas;
  FUNCTION f_conteo_finanzas(p_user NUMBER) RETURN NUMBER IS
    v_total NUMBER;
  BEGIN SELECT COUNT(*) INTO v_total FROM finanzas WHERE user_id=p_user; RETURN v_total; END f_conteo_finanzas;
  FUNCTION f_balance_resumido(p_user NUMBER) RETURN NUMBER IS
  BEGIN RETURN f_get_balance(p_user); END f_balance_resumido;
END fingo_pkg;
/

-- PAQUETE 2: reportes_pkg 
CREATE OR REPLACE PACKAGE reportes_pkg IS
  CURSOR c_gastos_detallados(p_user NUMBER, p_mes NUMBER, p_anio NUMBER) IS
    SELECT f.fecha_trx, c.nombre AS categoria, f.monto, f.descripcion
    FROM finanzas f JOIN categorias c ON f.categoria_id = c.id
    WHERE f.user_id = p_user AND f.tipo = 'gasto' AND EXTRACT(MONTH FROM f.fecha_trx) = p_mes AND EXTRACT(YEAR FROM f.fecha_trx) = p_anio ORDER BY f.fecha_trx DESC;
  PROCEDURE p_generar_reporte_gastos(p_user NUMBER, p_mes NUMBER, p_anio NUMBER);
  CURSOR c_metas_pendientes(p_user NUMBER) IS
    SELECT nombre, monto_objetivo, progreso, fecha_limite FROM metas_financieras WHERE user_id = p_user AND estado = 'en progreso' ORDER BY fecha_limite ASC;
  PROCEDURE p_listar_metas_pendientes(p_user NUMBER);
END reportes_pkg;
/
CREATE OR REPLACE PACKAGE BODY reportes_pkg IS
  PROCEDURE p_generar_reporte_gastos(p_user NUMBER, p_mes NUMBER, p_anio NUMBER) IS
    v_total_gastos NUMBER := 0;
  BEGIN
    DBMS_OUTPUT.PUT_LINE('--- REPORTE DE GASTOS: ' || p_mes || '/' || p_anio || ' ---');
    FOR v_rec IN c_gastos_detallados(p_user, p_mes, p_anio) LOOP
      DBMS_OUTPUT.PUT_LINE('Cat: ' || v_rec.categoria || ' | Monto: ' || TO_CHAR(v_rec.monto, '99,999.99'));
      v_total_gastos := v_total_gastos + v_rec.monto;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('TOTAL GASTADO: ' || TO_CHAR(v_total_gastos, '99,999.99'));
  END p_generar_reporte_gastos;
  PROCEDURE p_listar_metas_pendientes(p_user NUMBER) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('--- METAS PENDIENTES ---');
    FOR v_rec IN c_metas_pendientes(p_user) LOOP
      DBMS_OUTPUT.PUT_LINE('Meta: ' || v_rec.nombre || ' | Progreso: ' || v_rec.progreso);
    END LOOP;
  END p_listar_metas_pendientes;
END reportes_pkg;
/

-- PAQUETE 3: presupuesto_pkg 
CREATE OR REPLACE PACKAGE presupuesto_pkg IS
  CURSOR c_presupuestos_user(p_user NUMBER) IS SELECT * FROM presupuestos WHERE user_id = p_user;
  CURSOR c_presupuestos_excedidos(p_user NUMBER) IS
    SELECT p.id, p.monto_limite, c.nombre AS categoria
    FROM presupuestos p JOIN categorias c ON p.categoria_id = c.id
    WHERE p.user_id = p_user AND f_es_presupuesto_excedido(p.id) = 'SI';
  PROCEDURE p_listar_presupuestos(p_user NUMBER);
  PROCEDURE p_listar_excedidos(p_user NUMBER);
END presupuesto_pkg;
/
CREATE OR REPLACE PACKAGE BODY presupuesto_pkg IS
  PROCEDURE p_listar_presupuestos(p_user NUMBER) IS
  BEGIN
    FOR rec IN c_presupuestos_user(p_user) LOOP DBMS_OUTPUT.PUT_LINE('ID: ' || rec.id || ', Limite: ' || rec.monto_limite); END LOOP;
  END p_listar_presupuestos;
  PROCEDURE p_listar_excedidos(p_user NUMBER) IS
  BEGIN
    FOR rec IN c_presupuestos_excedidos(p_user) LOOP DBMS_OUTPUT.PUT_LINE('EXCEDIDO: ' || rec.categoria || ', Límite: ' || rec.monto_limite); END LOOP;
  END p_listar_excedidos;
END presupuesto_pkg;
/

-- PAQUETE 4: log_seguridad_pkg 
CREATE OR REPLACE PACKAGE log_seguridad_pkg IS
  CURSOR c_logs_recientes(p_user NUMBER) IS SELECT fecha_ingreso, ip, dispositivo FROM logs_acceso WHERE user_id = p_user ORDER BY fecha_ingreso DESC;
  PROCEDURE p_listar_logs(p_user NUMBER);
END log_seguridad_pkg;
/
CREATE OR REPLACE PACKAGE BODY log_seguridad_pkg IS
  PROCEDURE p_listar_logs(p_user NUMBER) IS
  BEGIN
    FOR rec IN c_logs_recientes(p_user) LOOP DBMS_OUTPUT.PUT_LINE('Fecha: ' || rec.fecha_ingreso || ', IP: ' || rec.ip); END LOOP;
  END p_listar_logs;
END log_seguridad_pkg;
/

-- PAQUETE 5: admin_alertas_pkg 
CREATE OR REPLACE PACKAGE admin_alertas_pkg IS
  CURSOR c_alertas_enviadas(p_user NUMBER) IS SELECT mensaje, fecha_envio FROM alertas WHERE user_id = p_user AND fecha_envio IS NOT NULL;
  CURSOR c_alertas_pendientes(p_user NUMBER) IS SELECT mensaje, tipo FROM alertas WHERE user_id = p_user AND fecha_envio IS NULL;
  PROCEDURE p_enviar_alerta(p_alerta_id IN NUMBER);
  PROCEDURE p_listar_pendientes(p_user NUMBER);
END admin_alertas_pkg;
/
CREATE OR REPLACE PACKAGE BODY admin_alertas_pkg IS
  PROCEDURE p_enviar_alerta(p_alerta_id IN NUMBER) IS
  BEGIN UPDATE alertas SET fecha_envio = SYSTIMESTAMP WHERE id = p_alerta_id; COMMIT; END p_enviar_alerta;
  PROCEDURE p_listar_pendientes(p_user NUMBER) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('--- ALERTAS PENDIENTES ---');
    FOR rec IN c_alertas_pendientes(p_user) LOOP DBMS_OUTPUT.PUT_LINE('TIPO: ' || rec.tipo || ', Mensaje: ' || rec.mensaje); END LOOP;
  END p_listar_pendientes;
END admin_alertas_pkg;
/
